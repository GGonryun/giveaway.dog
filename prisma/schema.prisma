generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

enum UserType {
  HOST
  PARTICIPATE
}

model User {
  id              String           @id @default(cuid())
  name            String?
  email           String?          @unique
  emailVerified   DateTime?
  image           String?
  age             Int?
  emoji           String?
  region          String?
  type            UserType[]       @default([PARTICIPATE])
  accounts        Account[]
  sessions        Session[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  teams           Membership[]
  taskCompletions TaskCompletion[]
  taskProgresses  TaskProgress[]
  winners         PrizeWinners[]
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

// WARNING: sweepstakes objects are too complex to update directly, instead we delete
// the whole sweepstake and recreate it. This may have catastrophic effects on nested,
// child, or down-stream data.
//
// Do not cascade data off deletes unless it's directly tied to the Sweepstakes object.
// For example, if we are to cascade on delete remove task participation, then changing
// the name would accidentally reset participation data.
model Sweepstakes {
  id     String            @id // takes nanoid's
  status SweepstakesStatus @default(DRAFT)

  teamId String?
  team   Team?   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  details  SweepstakesDetails?
  timing   SweepstakesTiming?
  terms    SweepstakesTerms?
  audience SweepstakesAudience?
  prizes   Prize[]
  tasks    Task[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model SweepstakesTiming {
  id            String      @id @default(cuid())
  sweepstakesId String      @unique
  sweepstakes   Sweepstakes @relation(fields: [sweepstakesId], references: [id], onDelete: Cascade)

  startDate DateTime?
  endDate   DateTime?
  timeZone  String?
}

model SweepstakesDetails {
  id            String      @id @default(cuid())
  sweepstakesId String      @unique
  sweepstakes   Sweepstakes @relation(fields: [sweepstakesId], references: [id], onDelete: Cascade)

  name        String?
  description String?
  banner      String?
}

model SweepstakesAudience {
  id            String      @id @default(cuid())
  sweepstakesId String      @unique
  sweepstakes   Sweepstakes @relation(fields: [sweepstakesId], references: [id], onDelete: Cascade)

  requireEmail          Boolean?
  regionalRestriction   RegionalRestriction?
  minimumAgeRestriction MinimumAgeRestriction?
}

enum SweepstakesStatus {
  DRAFT
  PAUSED
  CANCELED
  ACTIVE
  COMPLETED
}

enum SweepstakesTermsType {
  TEMPLATE
  CUSTOM
}

model SweepstakesTerms {
  id            String      @id @default(cuid())
  sweepstakesId String      @unique
  sweepstakes   Sweepstakes @relation(fields: [sweepstakesId], references: [id], onDelete: Cascade)

  type                      SweepstakesTermsType?
  sponsorName               String?
  sponsorAddress            String?
  winnerSelectionMethod     String?
  notificationTimeframeDays Int?
  maxEntriesPerUser         Int?
  claimDeadlineDays         Int?
  governingLawCountry       String?
  privacyPolicyUrl          String?
  additionalTerms           String?
  text                      String?
}

model RegionalRestriction {
  id         String              @id @default(cuid())
  audienceId String              @unique
  audience   SweepstakesAudience @relation(fields: [audienceId], references: [id], onDelete: Cascade)

  filter  RegionalRestrictionFilter?
  regions String[]                   @default([])
}

enum RegionalRestrictionFilter {
  INCLUDE
  EXCLUDE
}

enum MinimumAgeRestrictionFormat {
  CHECKBOX
}

model MinimumAgeRestriction {
  id         String              @id @default(cuid())
  audienceId String              @unique
  audience   SweepstakesAudience @relation(fields: [audienceId], references: [id], onDelete: Cascade)

  value    Int? // e.g. 18
  label    String? // e.g. "Must be 18 or older"
  required Boolean? // true if checkbox is mandatory
  format   MinimumAgeRestrictionFormat? @default(CHECKBOX) // future proofing
}

model Prize {
  id String @id

  sweepstakesId String
  sweepstakes   Sweepstakes @relation(fields: [sweepstakesId], references: [id], onDelete: Cascade)

  name  String?
  index Int?
  quota Int?

  winners PrizeWinners[]
}

model PrizeWinners {
  id String @id

  prizeId String
  prize   Prize  @relation(fields: [prizeId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Task {
  id            String      @id
  sweepstakesId String
  sweepstakes   Sweepstakes @relation(fields: [sweepstakesId], references: [id], onDelete: Cascade)

  index Int?

  config Json? // tasks are very complex objects, so we simply store them as json objects for now.

  completions TaskCompletion[]
  progress    TaskProgress[]

  @@unique([sweepstakesId, index])
}

enum TaskType {
  BONUS_TASK
  VISIT_URL
}

model TaskCompletion {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  taskId String
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  completedAt DateTime         @default(now())
  proof       Json?
  status      CompletionStatus @default(COMPLETED)
}

model TaskProgress {
  id String @id @default(cuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  taskId String
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  count     Int      @default(0) // how many times completed
  updatedAt DateTime @updatedAt

  @@unique([userId, taskId])
}

enum CompletionStatus {
  PENDING
  COMPLETED
  REJECTED
}

model Team {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  logo      String   @default("üê∂")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members     Membership[]
  sweepstakes Sweepstakes[]
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
  GUEST
  BLOCKED
}

model Membership {
  id     String   @id @default(cuid())
  userId String
  teamId String
  role   TeamRole

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Metadata for uploaded images. 
// Maps to the PutBlobResult of Vercel Blob API
model ImageMetadata {
  id          String @id @default(cuid())
  url         String
  downloadUrl String
  pathname    String
  contentType String
}
